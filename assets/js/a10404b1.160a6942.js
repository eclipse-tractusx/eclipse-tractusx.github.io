"use strict";(self.webpackChunkeclipse_tractusx_github_io=self.webpackChunkeclipse_tractusx_github_io||[]).push([[97374],{28453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>l});var n=s(96540);const i={},r=n.createContext(i);function a(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:t},e.children)}},82213:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"release/trg-3/trg-3-2","title":"TRG 3.02 - Persist Data","description":"| Status | Created     | Post-History      |","source":"@site/docs/release/trg-3/trg-3-2.md","sourceDirName":"release/trg-3","slug":"/release/trg-3/trg-3-2","permalink":"/docs/release/trg-3/trg-3-2","draft":false,"unlisted":false,"editUrl":"https://github.com/eclipse-tractusx/eclipse-tractusx.github.io/tree/main/docs/release/trg-3/trg-3-2.md","tags":[],"version":"current","frontMatter":{"title":"TRG 3.02 - Persist Data"},"sidebar":"docs","previous":{"title":"TRG 2.05 - Repository metafile","permalink":"/docs/release/trg-2/trg-2-5"},"next":{"title":"TRG 4.01 - Image tagging","permalink":"/docs/release/trg-4/trg-4-01"}}');var i=s(74848),r=s(28453);const a={title:"TRG 3.02 - Persist Data"},l=void 0,o={},d=[{value:"Why",id:"why",level:2},{value:"Description",id:"description",level:2},{value:"How",id:"how",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Status"}),(0,i.jsx)(t.th,{children:"Created"}),(0,i.jsx)(t.th,{children:"Post-History"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Draft"}),(0,i.jsx)(t.td,{children:"17-Jul-2023"}),(0,i.jsx)(t.td,{children:"'loos' typo fix"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Active"}),(0,i.jsx)(t.td,{children:"07-Mar-2023"}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Draft"}),(0,i.jsx)(t.td,{children:"02-Jan-2023"}),(0,i.jsx)(t.td,{children:"n/a"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Moved"}),(0,i.jsx)(t.td,{children:"02-Jan-2023"}),(0,i.jsx)(t.td,{children:"content moved"})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"why",children:"Why"}),"\n",(0,i.jsxs)(t.p,{children:["In cases where data has to be persisted (database, uploaded files etc.), Kubernetes ",(0,i.jsx)(t.strong,{children:"must"})," be configured to create Persistent Volume that is attached to an underlying disk where data remains even after the deletion of the application. Otherwise, an incidental deletion will delete all state."]}),"\n",(0,i.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(t.p,{children:"Using stateful data requires additional caution to not lose data by accident. Therefore, when a pod/deployment/statefulset resource is removed, data will still be available on the StorageClass's disk that was used."}),"\n",(0,i.jsx)(t.p,{children:'Persistent Volumes can have different reclaim policies, such as "Retain," "Recycle," and "Delete". The default reclaim policy is set to "Delete" for dynamically provisioned PVs. This implies that provisioned persistent volume gets automatically erased when a user removes the associated PersistentVolumeClaim. However, this automated deletion might not be suitable, especially if the volume contains valuable data. In such scenarios, opting for the "Retain" policy is more fitting. With the "Retain" policy, deleting a PersistentVolumeClaim won\'t result in the corresponding PersistentVolume being deleted, allowing users to manually recover all of its data.'}),"\n",(0,i.jsx)(t.h2,{id:"how",children:"How"}),"\n",(0,i.jsx)(t.p,{children:"Example PersistentVolumeClaim:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"# pvc.yaml\nkind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: pvc-persistent-tmp-demo\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 50Mi\n"})}),"\n",(0,i.jsx)(t.p,{children:"This can be referenced in the volumes section of a Pod/Deployment/StatefulSet resource:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"# deployment.yaml\n#...\n      volumes:\n        - name: pv-tmp-demo\n          persistentVolumeClaim:\n            claimName: pvc-persistent-tmp-demo\n#...\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["It is not recommended to directly request the claim in a StatefulSet! Rather create the PVC separately and reference that as an existing claim. See the example in ",(0,i.jsx)(t.a,{href:"https://github.com/bitnami/charts/tree/main/bitnami/postgresql",children:"Bitnami's Postgresql chart"})," where an existing claim can be referenced for the primary database at the ",(0,i.jsx)(t.a,{href:"https://github.com/bitnami/charts/tree/main/bitnami/postgresql#postgresql-primary-parameters",children:"primary.persistence.existingClaim property"}),"."]})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);