"use strict";(self.webpackChunkeclipse_tractusx_github_io=self.webpackChunkeclipse_tractusx_github_io||[]).push([[45993],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),u=a,g=d["".concat(l,".").concat(u)]||d[u]||h[u]||o;return n?i.createElement(g,r(r({ref:t},p),{},{components:n})):i.createElement(g,r({ref:t},p))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:a,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},84156:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var i=n(87462),a=(n(67294),n(3905));const o={sidebar_position:3,title:"Data Sovereignity, Policies and Upgradability"},r=void 0,s={unversionedId:"kits/knowledge-agents/operation-view/policy",id:"version-24.08/kits/knowledge-agents/operation-view/policy",title:"Data Sovereignity, Policies and Upgradability",description:"\x3c!--",source:"@site/docs-kits_versioned_docs/version-24.08/kits/knowledge-agents/operation-view/policy.md",sourceDirName:"kits/knowledge-agents/operation-view",slug:"/kits/knowledge-agents/operation-view/policy",permalink:"/docs-kits/kits/knowledge-agents/operation-view/policy",draft:!1,tags:[],version:"24.08",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Data Sovereignity, Policies and Upgradability"},sidebar:"kits",previous:{title:"Bridging",permalink:"/docs-kits/kits/knowledge-agents/operation-view/bridge"},next:{title:"Testbed",permalink:"/docs-kits/kits/knowledge-agents/operation-view/testbed"}},l={},c=[{value:"Catena-X Asset Property Standards",id:"catena-x-asset-property-standards",level:2},{value:"Catena-X Policy Profiles",id:"catena-x-policy-profiles",level:2},{value:"Data Sovereignity Through Backend Authentication",id:"data-sovereignity-through-backend-authentication",level:2},{value:"Data Sovereignity Through Bindings",id:"data-sovereignity-through-bindings",level:2},{value:"Data Sovereignity Through Asset Descriptions",id:"data-sovereignity-through-asset-descriptions",level:2},{value:"Data Sovereignity Through Contracts",id:"data-sovereignity-through-contracts",level:2},{value:"Data Sovereignity Through Combined Policies",id:"data-sovereignity-through-combined-policies",level:2}],p={toc:c};function d(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,i.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This document describes how Data Sovereignity and Upgradability can be reached in publishing Graphs and Skills by employing appropriate Policies and Versioning strategies."),(0,a.kt)("p",null,"For more information see"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Our ",(0,a.kt)("a",{parentName:"li",href:"../adoption-view/intro"},"Adoption")," guideline"),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("a",{parentName:"li",href:"../development-view/architecture"},"Architecture")," documentation"),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("a",{parentName:"li",href:"agent_edc"},"EDC Deployment")," description"),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("a",{parentName:"li",href:"provider"},"Provider Deployment")," description"),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("a",{parentName:"li",href:"bridge"},"AAS Bridge Deployment")," description"),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("a",{parentName:"li",href:"testbed"},"Conformity")," testbed")),(0,a.kt)("p",null,"The core ingredient to the KA Semantic Dataspace Architecture is that business partners (the Providers) offer RDF-based query endpoints (",(0,a.kt)("a",{parentName:"p",href:"provider"},"Graph Assets"),") over their ",(0,a.kt)("a",{parentName:"p",href:"agent_edc"},"Agent-Enabled Connector"),". The RDF endpoints (called binding ",(0,a.kt)("em",{parentName:"p"},"agents"),', because they are active components that do not contain data, but simply transform queries into the backend protocols) stay in an "internal" network (as the data- and logic-carrying backends that they interface/transform into) while the EDC\'s (through asset descriptors, contract definitions and access/contract policies) operate as bridges to the "public" network.'),(0,a.kt)("p",null,"Although the EDC network is technically based on public interfaces, it is by the builtin Self-Sovereign Identity (SSI) architecture that any network call will be validated wrt to the calling tenant's identity and contractual situation (use case participations and proven certificates)."),(0,a.kt)("p",null,'Although the EDC transfer protocols are used to "tunnel" more specific application protocols and endpoints, it is by the flexible description and filtering of those endpoints as data catalogue offers with extensible properties that any application can infer the correct target asset to interact with.  '),(0,a.kt)("p",null,'On the other hand, being free/sovereign to define these policies and properties at will gives the partipants a tremendous burden not to (unintendedly) breaking the deep data chains (in the knowledge agent case: deep nested executions) for the most valuable use cases. That is because these "hickups" will only occur data-driven at runtime by empty catalogue offers or failed transfers in unforeseeable places.'),(0,a.kt)("h2",{id:"catena-x-asset-property-standards"},"Catena-X Asset Property Standards"),(0,a.kt)("p",null,"To mitigate this problem, Catena-X requires two specific mandatory asset/offer properties:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},'"cx-common:protocol" should refer to a known transfer protocol ("cx-common:" is an abbreviation for ',(0,a.kt)("a",{parentName:"li",href:"https://w3id.org/catenax/ontology/common#"},"https://w3id.org/catenax/ontology/common#"),")"),(0,a.kt)("li",{parentName:"ul"},'"dct:type" should refer to a concept from the Catena-X Asset Taxonomy ("dct:" is an abbreviation for ',(0,a.kt)("a",{parentName:"li",href:"https://purl.org/dc/terms/"},"https://purl.org/dc/terms/"),'; "cx-taxo:" is an abbreviation for ',(0,a.kt)("a",{parentName:"li",href:"https://w3id.org/catenax/taxonomy#"},"https://w3id.org/catenax/taxonomy#"),")."),(0,a.kt)("li",{parentName:"ul"},'"cx-common:version" should carry a version string')),(0,a.kt)("p",null,"For our purpose, the Agents KIT distinguishes two protocols:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},'"cx-common:Protocol?w3c:http:SPARQL" which describes querying with SPARQL over HTTP (POST or GET)'),(0,a.kt)("li",{parentName:"ul"},'"cx-common:Protocol?w3c:http:SKILL" which describes invoking and binding SKILLs over HTTP (POST or GET)')),(0,a.kt)("p",null,"The Agents KIT introduces two asset concepts accordingly:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},'"cx-taxo:GraphAsset" for Graph-based Assets (pointing to binding agents)'),(0,a.kt)("li",{parentName:"ul"},'"cx-taxo:SkillAsset" for Skill Assets (containing parameterizable SPARQL queries)')),(0,a.kt)("p",null,"Finally, we suggest to use semantic versioning in the version property where the versions should be aligned with the use case KIT versions."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},'"',"[0-9]","+.","[0-9]","+.","[0-9]",'+(-SNAPSHOT)?"')),(0,a.kt)("p",null,"A Skill which is depending on a particular (minimal, maximal, exact) version of the Catena-X ontology (and its use-case relevant domain ontologies) to be realised could use the builtin SPARQL functions to filter the appropriate assets from the federated data catalogue. In the following example, we list all the found assets (together with their connectors) ordered by the highest version."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sparql"},"PREFIX sh: <http://www.w3.org/ns/shacl#>\nPREFIX schema: <http://schema.org/>\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nPREFIX cx-common: <https://w3id.org/catenax/ontology/common#> \nPREFIX cx-taxo: <https://w3id.org/catenax/taxonomy#>\nPREFIX dct: <https://purl.org/dc/terms/>\n\n# This query filters the federated data catalogue for 'production' behavioural graphs \n# in versions between 1.11 (inclusive) and 2 (exclusive)\n\nselect ?connector ?asset ?version where {      \n    ?connector cx-common:offers ?asset.\n    ?asset dct:type cx-taxo:GraphAsset;\n           rdfs:isDefinedBy <https://w3id.org/catenax/ontology/behaviour>;\n               cx-common:version ?version.\n\n        FILTER (!strends(?version, 'SNAPSHOT')).\n        FILTER (?version >= '1.11').\n        FILTER (?version < '2.').\n} ORDER BY DESC(?version)\n")),(0,a.kt)("p",null,"A result from would look like this"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "head": {\n        "vars": [\n            "connector",\n            "asset",\n            "version"\n        ]\n    },\n    "results": {\n        "bindings": [\n            {\n                "connector": {\n                    "type": "uri",\n                    "value": "edcs://knowledge.dev.demo.catena-x.net/tiera-edc-control/BPNL00000003CPIY"\n                },\n                "asset": {\n                    "type": "uri",\n                    "value": "cx-taxo:GraphAsset?supplier=BehaviourTwinRUL"\n                },\n                "version": {\n                    "type": "literal",\n                    "value": "1.12.19"\n                }\n            },\n            {\n                "connector": {\n                    "type": "uri",\n                    "value": "edcs://knowledge.dev.demo.catena-x.net/tiera-edc-control/BPNL00000003CPIY"\n                },\n                "asset": {\n                    "type": "uri",\n                    "value": "cx-taxo:GraphAsset?supplier=HealthIndicatorGearbox"\n                },\n                "version": {\n                    "type": "literal",\n                    "value": "1.11.16"\n                }\n            }\n        ]\n    }\n}\n')),(0,a.kt)("h2",{id:"catena-x-policy-profiles"},"Catena-X Policy Profiles"),(0,a.kt)("p",null,"Furthermore, Catena-X introduces so-called policy profiles which ensure that only pre-negotiatable and predictable constraints are used in the permissions, duties and obligations."),(0,a.kt)("p",null,"Two examples for such use-case specific policies following the Catena-X profile and being based on separated signed (and technicall attested) framework agreements are the\nBehaviour Twin Framework Agreement (in verson 1) and the Traceability Agreement (in version 3)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "@context": [\n        "http://www.w3.org/ns/odrl.jsonld", \n        {\n            "edc": "https://w3id.org/edc/v0.0.1/ns/"\n        },\n        {\n            "cx-policy": "https://w3id.org/catenax/policy/"\n        }\n    ],\n    "@type": "PolicyDefinitionRequestDto",\n    "@id": "GraphAsset?me=Policy&useCase=BehaviourTwin",\n    "edc:policy": {\n        "@type": "Set",\n        "profile": "cx-policy:profile2405",\n        "permission": [\n            {\n                "action": "use",\n                "constraint": {\n                    "leftOperand": "cx-policy:FrameworkAgreement",\n                    "operator": "eq",\n                    "rightOperand": "behaviourtwin:1.0"\n                }\n            }\n        ]\n    }\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "@context": [\n        "http://www.w3.org/ns/odrl.jsonld", \n        {\n            "edc": "https://w3id.org/edc/v0.0.1/ns/"\n        },\n        {\n            "cx-policy": "https://w3id.org/catenax/policy/"\n        }\n    ],\n    "@type": "PolicyDefinitionRequestDto",\n    "@id": "GraphAsset?me=Policy&useCase=Trace",\n    "edc:policy": {\n        "@type": "Set",\n        "profile": "cx-policy:profile2405",\n        "permission": [\n            {\n                "action": "use",\n                "constraint": {\n                    "leftOperand": "cx-policy:FrameworkAgreement",\n                    "operator": "eq",\n                    "rightOperand": "traceability:3.0"\n                }\n            }\n        ]\n    }\n}\n')),(0,a.kt)("p",null,"For the purpose of this investigation, let us now assume that we have to publish a single backend (=database, datalake schema or API endpoint) into multiple use cases.\nIn the following the different levels of tailoring access (by authentication, by configuration, by publishing/policying) are discussed that can be used to govern this scenario."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Data Sovereignity Through Offering and Policy Validation",src:n(11386).Z,width:"1002",height:"770"})),(0,a.kt)("h2",{id:"data-sovereignity-through-backend-authentication"},"Data Sovereignity Through Backend Authentication"),(0,a.kt)("p",null,"On this level, technical roles can be introduced in the backend systems (technical users) for the different use cases. Each technical user would only be allowed to\nmanipulate (read, update, delete) the relevant part of the API or data schema."),(0,a.kt)("p",null,"Then different RDF endpoints are created which may share the same binding but use a different technical user to access the single backend. Each RDF endpoint would then be mapped into a different asset (with a similar self-description, but a slightly different shape). The assets would be offerred via different contracts and different policies."),(0,a.kt)("h2",{id:"data-sovereignity-through-bindings"},"Data Sovereignity Through Bindings"),(0,a.kt)("p",null,"On this level, different RDF endpoints are introduced which use the same technical user to access the single backend, but they make use of different bindings to map only a part of the SPARQL protocol to a part of the backend protocols. Each RDF endpoint would then be mapped into a different asset (with a similar self-description, but a slightly different shape). The assets would be offerred via different contracts and different policies."),(0,a.kt)("h2",{id:"data-sovereignity-through-asset-descriptions"},"Data Sovereignity Through Asset Descriptions"),(0,a.kt)("p",null,'On this level, a single RDF endpoint is introduced which is mapped into a different asset (with a similar self-description, but a slightly different shape). The assets would be offerred via different contracts and different policies. For this purpose, a "shape-filter" (not yet implemented) could become active in the Agent Plane/Matchmaking Agent which rewrites or checks the\nincoming SPARQL context before delegating it to the binding agent.'),(0,a.kt)("h2",{id:"data-sovereignity-through-contracts"},"Data Sovereignity Through Contracts"),(0,a.kt)("p",null,"On this level, a single asset description is used which is embedded into different contracts with different policies."),(0,a.kt)("h2",{id:"data-sovereignity-through-combined-policies"},"Data Sovereignity Through Combined Policies"),(0,a.kt)("p",null,"On this level,a single contract is used with a combined policy"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "@context": [\n        "http://www.w3.org/ns/odrl.jsonld", \n        {\n            "edc": "https://w3id.org/edc/v0.0.1/ns/"\n        },\n        {\n            "cx-policy": "https://w3id.org/catenax/policy/"\n        }\n    ],\n    "@type": "PolicyDefinitionRequestDto",\n    "@id": "GraphAsset?me=Policy&useCase=Trace&useCase=BehaviourTwin",\n    "edc:policy": {\n        "@type": "Set",\n        "profile": "cx-policy:profile2405",\n        "permission": [\n            {\n                "action": "use",\n                "constraint": {\n                  "@type": "LogicalConstraint",\n                  "or" : [{\n                      "leftOperand": "cx-policy:FrameworkAgreement",\n                      "operator": "eq",\n                      "rightOperand": "behaviourtwin:1.0"\n                      },\n                      {\n                      "leftOperand": "cx-policy:FrameworkAgreement",\n                      "operator": "eq",\n                      "rightOperand": "traceability:3.0"\n                      }]\n                }\n            }\n        ]\n    }\n}\n')),(0,a.kt)("sub",null,(0,a.kt)("sup",null,"(C) 2021,2024 Contributors to the Eclipse Foundation. SPDX-License-Identifier: CC-BY-4.0")))}d.isMDXComponent=!0},11386:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/graph_asset-2eddab5399af65daca9cd00a9050eab7.png"}}]);